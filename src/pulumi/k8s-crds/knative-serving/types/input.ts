// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from ".";

import {ObjectMeta} from "../meta/v1";

export namespace autoscaling {
    export namespace v1alpha1 {
        /**
         * Spec holds the desired state of the Metric (from the client).
         */
        export interface MetricSpecArgs {
            /**
             * PanicWindow is the aggregation window for metrics where quick reactions are needed.
             */
            panicWindow: pulumi.Input<number>;
            /**
             * ScrapeTarget is the K8s service that publishes the metric endpoint.
             */
            scrapeTarget: pulumi.Input<string>;
            /**
             * StableWindow is the aggregation window for metrics in a stable state.
             */
            stableWindow: pulumi.Input<number>;
        }

        /**
         * Status communicates the observed state of the Metric (from the controller).
         */
        export interface MetricStatusArgs {
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.autoscaling.v1alpha1.MetricStatusConditionsArgs>[]>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface MetricStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec holds the desired state of the PodAutoscaler (from the client).
         */
        export interface PodAutoscalerSpecArgs {
            /**
             * ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container of the Revision. Defaults to `0` which means unlimited concurrency.
             */
            containerConcurrency?: pulumi.Input<number>;
            /**
             * The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.
             */
            protocolType: pulumi.Input<string>;
            /**
             * Reachability specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route). Defaults to `ReachabilityUnknown`
             */
            reachability?: pulumi.Input<string>;
            /**
             * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler is responsible for quickly right-sizing.
             */
            scaleTargetRef: pulumi.Input<inputs.autoscaling.v1alpha1.PodAutoscalerSpecScaleTargetRefArgs>;
        }

        /**
         * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler is responsible for quickly right-sizing.
         */
        export interface PodAutoscalerSpecScaleTargetRefArgs {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Status communicates the observed state of the PodAutoscaler (from the controller).
         */
        export interface PodAutoscalerStatusArgs {
            /**
             * ActualScale shows the actual number of replicas for the revision.
             */
            actualScale?: pulumi.Input<number>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.autoscaling.v1alpha1.PodAutoscalerStatusConditionsArgs>[]>;
            /**
             * DesiredScale shows the current desired number of replicas for the revision.
             */
            desiredScale?: pulumi.Input<number>;
            /**
             * MetricsServiceName is the K8s Service name that provides revision metrics. The service is managed by the PA object.
             */
            metricsServiceName: pulumi.Input<string>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * ServiceName is the K8s Service name that serves the revision, scaled by this PA. The service is created and owned by the ServerlessService object owned by this PA.
             */
            serviceName: pulumi.Input<string>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface PodAutoscalerStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace caching {
    export namespace v1alpha1 {
    }
}

export namespace networking {
    export namespace v1alpha1 {
    }
}

export namespace serving {
    export namespace v1 {
        /**
         * ConfigurationSpec holds the desired state of the Configuration (from the client).
         */
        export interface ConfigurationSpecArgs {
            /**
             * Template holds the latest specification for the Revision to be stamped out.
             */
            template?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateArgs>;
        }

        /**
         * Template holds the latest specification for the Revision to be stamped out.
         */
        export interface ConfigurationSpecTemplateArgs {
            metadata?: pulumi.Input<{[key: string]: any}>;
            /**
             * RevisionSpec holds the desired state of the Revision (from the client).
             */
            spec?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * ConfigurationStatus communicates the observed state of the Configuration (from the controller).
         */
        export interface ConfigurationStatusArgs {
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationStatusConditionsArgs>[]>;
            /**
             * LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
             */
            latestCreatedRevisionName?: pulumi.Input<string>;
            /**
             * LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its "Ready" condition become "True".
             */
            latestReadyRevisionName?: pulumi.Input<string>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface ConfigurationStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * RevisionStatus communicates the observed state of the Revision (from the controller).
         */
        export interface RevisionStatusArgs {
            /**
             * ActualReplicas reflects the amount of ready pods running this revision.
             */
            actualReplicas?: pulumi.Input<number>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionStatusConditionsArgs>[]>;
            /**
             * ContainerStatuses is a slice of images present in .Spec.Container[*].Image to their respective digests and their container name. The digests are resolved during the creation of Revision. ContainerStatuses holds the container name and image digests for both serving and non serving containers. ref: http://bit.ly/image-digests
             */
            containerStatuses?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionStatusContainerStatusesArgs>[]>;
            /**
             * DesiredReplicas reflects the desired amount of pods running this revision.
             */
            desiredReplicas?: pulumi.Input<number>;
            /**
             * LogURL specifies the generated logging url for this particular revision based on the revision url template specified in the controller's config.
             */
            logUrl?: pulumi.Input<string>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface RevisionStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ContainerStatus holds the information of container name and image digest value
         */
        export interface RevisionStatusContainerStatusesArgs {
            imageDigest?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
        }

        /**
         * Spec holds the desired state of the Route (from the client).
         */
        export interface RouteSpecArgs {
            /**
             * Traffic specifies how to distribute traffic over a collection of revisions and configurations.
             */
            traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteSpecTrafficArgs>[]>;
        }

        /**
         * TrafficTarget holds a single entry of the routing table for a Route.
         */
        export interface RouteSpecTrafficArgs {
            /**
             * ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.
             */
            configurationName?: pulumi.Input<string>;
            /**
             * LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.
             */
            latestRevision?: pulumi.Input<boolean>;
            /**
             * Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for   that particular Revision or Configuration
             */
            percent?: pulumi.Input<number>;
            /**
             * RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.
             */
            revisionName?: pulumi.Input<string>;
            /**
             * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
             */
            tag?: pulumi.Input<string>;
            /**
             * URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
             */
            url?: pulumi.Input<string>;
        }

        /**
         * Status communicates the observed state of the Route (from the controller).
         */
        export interface RouteStatusArgs {
            /**
             * Address holds the information needed for a Route to be the target of an event.
             */
            address?: pulumi.Input<inputs.serving.v1.RouteStatusAddressArgs>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteStatusConditionsArgs>[]>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
             */
            traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteStatusTrafficArgs>[]>;
            /**
             * URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
             */
            url?: pulumi.Input<string>;
        }

        /**
         * Address holds the information needed for a Route to be the target of an event.
         */
        export interface RouteStatusAddressArgs {
            url?: pulumi.Input<string>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface RouteStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * TrafficTarget holds a single entry of the routing table for a Route.
         */
        export interface RouteStatusTrafficArgs {
            /**
             * ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.
             */
            configurationName?: pulumi.Input<string>;
            /**
             * LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.
             */
            latestRevision?: pulumi.Input<boolean>;
            /**
             * Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for   that particular Revision or Configuration
             */
            percent?: pulumi.Input<number>;
            /**
             * RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.
             */
            revisionName?: pulumi.Input<string>;
            /**
             * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
             */
            tag?: pulumi.Input<string>;
            /**
             * URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
             */
            url?: pulumi.Input<string>;
        }

        /**
         * ServiceSpec represents the configuration for the Service object. A Service's specification is the union of the specifications for a Route and Configuration.  The Service restricts what can be expressed in these fields, e.g. the Route must reference the provided Configuration; however, these limitations also enable friendlier defaulting, e.g. Route never needs a Configuration name, and may be defaulted to the appropriate "run latest" spec.
         */
        export interface ServiceSpecArgs {
            /**
             * Template holds the latest specification for the Revision to be stamped out.
             */
            template?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateArgs>;
            /**
             * Traffic specifies how to distribute traffic over a collection of revisions and configurations.
             */
            traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTrafficArgs>[]>;
        }

        /**
         * Template holds the latest specification for the Revision to be stamped out.
         */
        export interface ServiceSpecTemplateArgs {
            metadata?: pulumi.Input<{[key: string]: any}>;
            /**
             * RevisionSpec holds the desired state of the Revision (from the client).
             */
            spec?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * TrafficTarget holds a single entry of the routing table for a Route.
         */
        export interface ServiceSpecTrafficArgs {
            /**
             * ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.
             */
            configurationName?: pulumi.Input<string>;
            /**
             * LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.
             */
            latestRevision?: pulumi.Input<boolean>;
            /**
             * Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for   that particular Revision or Configuration
             */
            percent?: pulumi.Input<number>;
            /**
             * RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.
             */
            revisionName?: pulumi.Input<string>;
            /**
             * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
             */
            tag?: pulumi.Input<string>;
            /**
             * URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
             */
            url?: pulumi.Input<string>;
        }

        /**
         * ServiceStatus represents the Status stanza of the Service resource.
         */
        export interface ServiceStatusArgs {
            /**
             * Address holds the information needed for a Route to be the target of an event.
             */
            address?: pulumi.Input<inputs.serving.v1.ServiceStatusAddressArgs>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceStatusConditionsArgs>[]>;
            /**
             * LatestCreatedRevisionName is the last revision that was created from this Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
             */
            latestCreatedRevisionName?: pulumi.Input<string>;
            /**
             * LatestReadyRevisionName holds the name of the latest Revision stamped out from this Configuration that has had its "Ready" condition become "True".
             */
            latestReadyRevisionName?: pulumi.Input<string>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
             */
            traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceStatusTrafficArgs>[]>;
            /**
             * URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
             */
            url?: pulumi.Input<string>;
        }

        /**
         * Address holds the information needed for a Route to be the target of an event.
         */
        export interface ServiceStatusAddressArgs {
            url?: pulumi.Input<string>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface ServiceStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * TrafficTarget holds a single entry of the routing table for a Route.
         */
        export interface ServiceStatusTrafficArgs {
            /**
             * ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one.  This field is never set in Route's status, only its spec.  This is mutually exclusive with RevisionName.
             */
            configurationName?: pulumi.Input<string>;
            /**
             * LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target.  When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty.
             */
            latestRevision?: pulumi.Input<boolean>;
            /**
             * Percent indicates that percentage based routing should be used and the value indicates the percent of traffic that is be routed to this Revision or Configuration. `0` (zero) mean no traffic, `100` means all traffic. When percentage based routing is being used the follow rules apply: - the sum of all percent values must equal 100 - when not specified, the implied value for `percent` is zero for   that particular Revision or Configuration
             */
            percent?: pulumi.Input<number>;
            /**
             * RevisionName of a specific revision to which to send this portion of traffic.  This is mutually exclusive with ConfigurationName.
             */
            revisionName?: pulumi.Input<string>;
            /**
             * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
             */
            tag?: pulumi.Input<string>;
            /**
             * URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
             */
            url?: pulumi.Input<string>;
        }
    }

    export namespace v1alpha1 {
        /**
         * Spec is the desired state of the DomainMapping. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DomainMappingSpecArgs {
            /**
             * Ref specifies the target of the Domain Mapping. 
             *  The object identified by the Ref must be an Addressable with a URL of the form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain, and `{name}` and `{namespace}` are the name and namespace of a Kubernetes Service. 
             *  This contract is satisfied by Knative types such as Knative Services and Knative Routes, and by Kubernetes Services.
             */
            ref: pulumi.Input<inputs.serving.v1alpha1.DomainMappingSpecRefArgs>;
            /**
             * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
             */
            tls?: pulumi.Input<inputs.serving.v1alpha1.DomainMappingSpecTlsArgs>;
        }

        /**
         * Ref specifies the target of the Domain Mapping. 
         *  The object identified by the Ref must be an Addressable with a URL of the form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain, and `{name}` and `{namespace}` are the name and namespace of a Kubernetes Service. 
         *  This contract is satisfied by Knative types such as Knative Services and Knative Routes, and by Kubernetes Services.
         */
        export interface DomainMappingSpecRefArgs {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup. Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
             */
            group?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
         */
        export interface DomainMappingSpecTlsArgs {
            /**
             * SecretName is the name of the existing secret used to terminate TLS traffic.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Status is the current state of the DomainMapping. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DomainMappingStatusArgs {
            /**
             * Address holds the information needed for a DomainMapping to be the target of an event.
             */
            address?: pulumi.Input<inputs.serving.v1alpha1.DomainMappingStatusAddressArgs>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1alpha1.DomainMappingStatusConditionsArgs>[]>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * URL is the URL of this DomainMapping.
             */
            url?: pulumi.Input<string>;
        }

        /**
         * Address holds the information needed for a DomainMapping to be the target of an event.
         */
        export interface DomainMappingStatusAddressArgs {
            url?: pulumi.Input<string>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface DomainMappingStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }
    }

    export namespace v1beta1 {
        /**
         * Spec is the desired state of the DomainMapping. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DomainMappingSpecArgs {
            /**
             * Ref specifies the target of the Domain Mapping. 
             *  The object identified by the Ref must be an Addressable with a URL of the form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain, and `{name}` and `{namespace}` are the name and namespace of a Kubernetes Service. 
             *  This contract is satisfied by Knative types such as Knative Services and Knative Routes, and by Kubernetes Services.
             */
            ref: pulumi.Input<inputs.serving.v1beta1.DomainMappingSpecRefArgs>;
            /**
             * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
             */
            tls?: pulumi.Input<inputs.serving.v1beta1.DomainMappingSpecTlsArgs>;
        }

        /**
         * Ref specifies the target of the Domain Mapping. 
         *  The object identified by the Ref must be an Addressable with a URL of the form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain, and `{name}` and `{namespace}` are the name and namespace of a Kubernetes Service. 
         *  This contract is satisfied by Knative types such as Knative Services and Knative Routes, and by Kubernetes Services.
         */
        export interface DomainMappingSpecRefArgs {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup. Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
             */
            group?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
         */
        export interface DomainMappingSpecTlsArgs {
            /**
             * SecretName is the name of the existing secret used to terminate TLS traffic.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Status is the current state of the DomainMapping. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DomainMappingStatusArgs {
            /**
             * Address holds the information needed for a DomainMapping to be the target of an event.
             */
            address?: pulumi.Input<inputs.serving.v1beta1.DomainMappingStatusAddressArgs>;
            /**
             * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Conditions the latest available observations of a resource's current state.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1beta1.DomainMappingStatusConditionsArgs>[]>;
            /**
             * ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * URL is the URL of this DomainMapping.
             */
            url?: pulumi.Input<string>;
        }

        /**
         * Address holds the information needed for a DomainMapping to be the target of an event.
         */
        export interface DomainMappingStatusAddressArgs {
            url?: pulumi.Input<string>;
        }

        /**
         * Condition defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
         */
        export interface DomainMappingStatusConditionsArgs {
            /**
             * LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
             */
            severity?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of condition.
             */
            type: pulumi.Input<string>;
        }
    }
}
