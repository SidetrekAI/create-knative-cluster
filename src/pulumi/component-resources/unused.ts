import * as pulumi from '@pulumi/pulumi'
import * as aws from '@pulumi/aws'
import * as k8s from '@pulumi/kubernetes'
import {
  getClusterAutoscalerPolicy,
  getRoleTrustPolicy,
} from '../iam-policies'

/**
 * Set up ClusterAutoscaler
 * 
 *    To verify: `kubectl logs <cluster-autoscaler deployment> -n kube-system`
 */
interface ClusterAutoscalerArgs {
  awsAccountId: string,
  awsRegion: string,
  clusterName: pulumi.Output<string>,
  eksHash: pulumi.Output<string>,
}

export class ClusterAutoscaler extends pulumi.ComponentResource {
  constructor(name: string, args: ClusterAutoscalerArgs, opts: any) {
    super('custom:k8s:ClusterAutoscaler', name, {}, opts)

    const {
      awsAccountId,
      awsRegion,
      clusterName,
      eksHash,
    } = args

    const clusterAutoscalerNamespaceName = 'kube-system'
    const clusterAutoscalerReleaseName = 'cluster-autoscaler-release'
    // IMPORTANT: must match the sa name generated by the helm chart below
    const clusterAutoscalerSaName = `${clusterAutoscalerReleaseName}-aws-cluster-autoscaler`

    // IAM role for Cluster Autoscaler
    const clusterAutoscalerRoleName = 'AmazonEKSClusterAutoscalerRole'
    const clusterAutoscalerRole = new aws.iam.Role(clusterAutoscalerRoleName, {
      namePrefix: clusterAutoscalerRoleName,
      assumeRolePolicy: getRoleTrustPolicy({
        awsRegion,
        awsAccountId,
        eksHash,
        namespace: clusterAutoscalerNamespaceName,
        serviceAccountName: clusterAutoscalerSaName,
      }),
    })
    const clusterAutoscalerPolicyName = 'AmazonEKSClusterAutoscalerPolicy'
    const clusterAutoscalerPolicy = new aws.iam.Policy(clusterAutoscalerPolicyName, {
      namePrefix: clusterAutoscalerPolicyName,
      description: 'Cluster Autoscaler policy',
      policy: getClusterAutoscalerPolicy(),
    })
    new aws.iam.RolePolicyAttachment(`cluster-autoscaler-role-policy`, {
      role: clusterAutoscalerRole,
      policyArn: clusterAutoscalerPolicy.arn,
    })

    // Set up Cluster Autoscaler via Helm
    const clusterAutoscaler = new k8s.helm.v3.Release(clusterAutoscalerReleaseName, {
      name: clusterAutoscalerReleaseName,
      namespace: clusterAutoscalerNamespaceName,
      chart: 'cluster-autoscaler',
      repositoryOpts: {
        repo: 'https://kubernetes.github.io/autoscaler',
      },
      values: {
        cloudProvider: 'aws',
        awsRegion,
        autoDiscovery: {
          clusterName,
        },
        rbac: {
          serviceAccount: {
            annotations: {
              'eks.amazonaws.com/role-arn': pulumi.interpolate`${clusterAutoscalerRole.arn}`
            }
          }
        },
      },
      cleanupOnFail: true,
    }, { parent: this })

    this.registerOutputs()
  }
}

interface KnativeOperatorArgs {
  version: string,
}

export class KnativeOperator extends pulumi.ComponentResource {
  resources: pulumi.Output<{ [key: string]: pulumi.CustomResource; }>

  constructor(name: string, args: KnativeOperatorArgs, opts: any) {
    super('custom:k8s:KnativeOperator', name, {}, opts)

    const { version } = args

    /**
     * Install knative operator
     * 
     *    CAVEAT: There's a Circular error that happens when Knative Operator stack is run twice - Pulumi attempts
     *            to destroy ConfigGroups and rebuild them which causes this Circular error (hangs while deleting)
     */
    const knativeOperator = new k8s.yaml.ConfigGroup(name, {
      files: `https://github.com/knative/operator/releases/download/knative-v${version}/operator.yaml`,
    }, { parent: this })

    // // HACK: try locally (Circular error issue)
    // // Install knative operator
    // const knativeOperator = new k8s.yaml.ConfigGroup(name, {
    //   files: path.resolve(process.cwd(), 'src/pulumi/knative-operator.yaml'),
    // }, { parent: this })

    this.resources = knativeOperator.resources

    this.registerOutputs()
  }
}

interface KnativeServingArgs {
  hostname: string,
  knativeHttpsIngressGatewayName: string,
  highAvailabilityReplicas?: number,
}

export class KnativeServing extends pulumi.ComponentResource {
  id: pulumi.Output<String>

  constructor(name: string, args: KnativeServingArgs, opts: any) {
    super('custom:k8s:KnativeServing', name, {}, opts)

    const {
      hostname,
      knativeHttpsIngressGatewayName,
      highAvailabilityReplicas = 2,
    } = args

    const knativeServingNamespaceName = 'knative-serving'
    const knativeServingName = 'knative-serving'

    // Install knative serving component
    const knativeServingNamespace = new k8s.core.v1.Namespace(knativeServingNamespaceName, {
      metadata: { name: knativeServingNamespaceName }
    }, { parent: this })

    const knativeServing = new k8s.apiextensions.CustomResource(knativeServingName, {
      apiVersion: 'operator.knative.dev/v1alpha1',
      kind: 'KnativeServing',
      metadata: {
        name: knativeServingName,
        namespace: knativeServingNamespace.metadata.name,
      },
      spec: {
        additionalManifests: [
          // this will make sure config-certmanager will be managed by Knative Serving CR
          { URL: 'https://github.com/knative/net-certmanager/releases/download/v0.26.0/release.yaml' },
          { URL: 'https://github.com/knative/serving/releases/download/v0.26.0/serving-nscert.yaml' },
        ],
        config: { // you can edit all ConfigMaps in knative operator namespace here
          domain: { // set up a custom domain
            [hostname]: '',
          },
          gc: { // keep around the last 20 non-active revisions
            'retain-since-create-time': 'disabled',
            'retain-since-last-active-time': 'disabled',
            'min-non-active-revisions': '4',
            'max-non-active-revisions': '6',
          },
          autoscaler: {
            // 'enable-scale-to-zero': 'false',
            'scale-to-zero-grace-period': '300s',
          },
          network: {
            autoTLS: 'Enabled', // requires cert-manager to be set up
            httpProtocol: 'Redirected', // redirects all http to https
          },
          certmanager: {
            issuerRef: '|\n  kind: ClusterIssuer\n  name: letsencrypt-dns-issuer\n',
          },
          istio: {
            [`gateway.knative-serving.${knativeHttpsIngressGatewayName}`]: 'istio-ingressgateway.istio-system.svc.cluster.local'
          },
        },
        'high-availability': {
          replicas: highAvailabilityReplicas
        },
      }
    }, { parent: this })

    this.id = knativeServing.id

    this.registerOutputs()
  }
}

export class KnativeEventing extends pulumi.ComponentResource {
  id: pulumi.Output<String>

  constructor(name: string, args: any, opts: any) {
    super('custom:k8s:KnativeEventing', name, {}, opts)

    const knativeEventingNamespaceName = 'knative-eventing'
    const knativeEventingName = 'knative-eventing'

    // Install knative serving component
    const knativeEventingNamespace = new k8s.core.v1.Namespace(knativeEventingNamespaceName, {
      metadata: { name: knativeEventingNamespaceName }
    }, { parent: this })

    const knativeEventing = new k8s.apiextensions.CustomResource(knativeEventingName, {
      apiVersion: 'operator.knative.dev/v1alpha1',
      kind: 'KnativeEventing',
      metadata: {
        name: knativeEventingName,
        namespace: knativeEventingNamespace.metadata.name,
      },
    }, { parent: this })

    this.id = knativeEventing.id

    this.registerOutputs()
  }
}

/**
 * Replace default knative-ingress-gateway with knative-https-ingress-gateway to allow tls traffic
 */
interface KnativeHttpsIngressGatewayArgs {
  hostname: string,
  knativeHttpsIngressGatewayName: string,
  wildcardCertificateSecretName: string,
}

export class KnativeHttpsIngressGateway extends pulumi.ComponentResource {
  id: pulumi.Output<String>
  name: String

  constructor(name: string, args: KnativeHttpsIngressGatewayArgs, opts: any) {
    super('custom:k8s:KnativeHttpsIngressGateway', name, {}, opts)

    const {
      hostname,
      knativeHttpsIngressGatewayName,
      wildcardCertificateSecretName,
    } = args

    const knativeHttpsIngressGateway = new k8s.apiextensions.CustomResource(knativeHttpsIngressGatewayName, {
      apiVersion: 'networking.istio.io/v1beta1',
      kind: 'Gateway',
      metadata: {
        name: knativeHttpsIngressGatewayName,
        namespace: 'knative-serving',
      },
      spec: {
        selector: {
          istio: 'ingressgateway'
        },
        servers: [
          {
            hosts: ['*'],
            port: {
              name: 'http',
              number: 80,
              protocol: 'HTTP'
            },
            tls: {
              httpsRedirect: true
            }
          },
          {
            hosts: [`*.${hostname}`],
            port: {
              name: 'https',
              number: 443,
              protocol: 'HTTPS'
            },
            tls: {
              credentialName: wildcardCertificateSecretName,
              mode: 'SIMPLE',
              privateKey: 'tls.key',
              serverCertificate: 'tls.crt'
            }
          },
        ]
      }
    }, { parent: this })

    this.id = knativeHttpsIngressGateway.id
    this.name = knativeHttpsIngressGatewayName

    this.registerOutputs()
  }
}

interface KnativeVirtualServiceArgs {
  useKnativeRouting?: boolean, // requires different VirtualService setup than usual Istio VirtualService for Knative svc - i.e. using host Header + knative-local-gateway
  namespace: string,
  gateways: string[],
  hosts: string[],
  routes: KnativeVirtualServiceRoute[],
}

interface KnativeVirtualServiceRoute {
  uri: string,
  rewriteUri: string,
  serviceHostname: string,
  port?: number,
  weight?: number,
}

export class KnativeVirtualService extends pulumi.ComponentResource {
  virtualService: k8s.apiextensions.CustomResource

  constructor(name: string, args: KnativeVirtualServiceArgs, opts: any) {
    super('custom:k8s:KnativeVirtualService', name, {}, opts)

    const {
      useKnativeRouting = false,
      namespace,
      gateways,
      hosts,
      routes,
    } = args

    this.virtualService = new k8s.apiextensions.CustomResource(name, {
      apiVersion: 'networking.istio.io/v1alpha3',
      kind: 'VirtualService',
      metadata: {
        namespace,
        name,
      },
      spec: {
        gateways,
        hosts, // Set host to the domain name that you own.
        http: routes.map(route => ({
          match: [
            {
              uri: {
                prefix: route.uri,
              }
            }
          ],
          // Rewrite the original host header to the host header of the service 
          // in order to redirect requests
          rewrite: {
            ...useKnativeRouting ? { authority: route.serviceHostname } : {},
            uri: route.rewriteUri,
          },
          // Basically here we redirect the request to the internal gateway with
          // updated header so the request will eventually be directed to the right service.
          route: [
            {
              destination: {
                host: useKnativeRouting ? `knative-local-gateway.istio-system.svc.cluster.local` : route.serviceHostname,
                port: {
                  number: route.port || 80,
                }
              },
              weight: route.weight || 100,
            }
          ]
        }))
      },
    }, { parent: this })

    this.registerOutputs()
  }
}

export class KnativeServiceMonitors extends pulumi.ComponentResource {
  constructor(name: string, args: any, opts: any) {
    super('custom:k8s:KnativeServiceMonitors', name, {}, opts)

    // Apply the ServiceMonitors/PodMonitors to collect metrics from Knative
    const serviceMonitorsName = 'service-monitors'
    const serviceMonitors = new k8s.yaml.ConfigGroup(serviceMonitorsName, {
      files: 'https://raw.githubusercontent.com/knative-sandbox/monitoring/main/servicemonitor.yaml',
    }, { parent: this })

    this.registerOutputs()
  }
}

export class KnativeGrafanaDashboards extends pulumi.ComponentResource {
  constructor(name: string, args: any, opts: any) {
    super('custom:k8s:KnativeGrafanaDashboards', name, {}, opts)

    // Import Grafana dashboards 
    const grafanaDashboardsName = 'grafana-dashboards'
    const grafanaDashboards = new k8s.yaml.ConfigGroup(grafanaDashboardsName, {
      files: 'https://raw.githubusercontent.com/knative-sandbox/monitoring/main/grafana/dashboards.yaml',
    }, { parent: this })

    this.registerOutputs()
  }
}